import functools
import math

def diffactor(G):

    zol = dict([(v, list()) for v in G.vs.indices])

    for x,y,z in itertools.combinations(G.vs.indices, 3):

      if G.get_eid(x,y,error=False) != -1 or G.get_eid(x,z,error=False) != -1 or G.get_eid(z,y, error=False) != -1:
        continue

      teamX = set(G.neighbors(x)) - set(G.neighbors(y)) - set(G.neighbors(z))
      teamY = set(G.neighbors(y)) - set(G.neighbors(x)) - set(G.neighbors(z))
      teamZ = set(G.neighbors(z)) - set(G.neighbors(y)) - set(G.neighbors(x))
      teamM = set(G.neighbors(x)) & set(G.neighbors(y)) & set(G.neighbors(z))

      teamX.add(x)
      teamY.add(y)
      teamZ.add(z)

      if x in teamY:
       teamY.remove(x)

      if y in teamX:
       teamX.remove(y)

      if y in teamZ:
       teamZ.remove(y)

      if x in teamZ:
       teamZ.remove(x)

      if z in teamX:
        teamX.remove(z)

      if z in teamY:
        teamY.remove(z)

      if y in teamM:
       teamM.remove(y)

      if z in teamM:
       teamM.remove(z)

      if x in teamM:
       teamM.remove(x)

      prev = len(teamX) + len(teamY) + len(teamZ) + len(teamM)
      total = prev

      while prev < G.vcount():
       tx = teamX.copy()
       ty = teamY.copy()
       tz = teamZ.copy()

       for peace in teamM.copy():
        n = set(G.neighbors(peace))
        a = len(n & tx)
        b = len(n & ty)
        c = len(n & tz)

        tr = [a, b, c]
        if len(set(tr)) == 3:
         if tr.index(max(a, b, c)) == 0:
          teamX.add(peace)
          teamM.remove(peace)
         elif tr.index(max(a, b, c)) == 1:
          teamY.add(peace)
          teamM.remove(peace)
         elif tr.index(max(a, b, c)) == 2:
          teamZ.add(peace)
          teamM.remove(peace)

       tx = teamX.copy()
       ty = teamY.copy()
       tz = teamZ.copy()

       for free in set(G.vs.indices) - (tx | ty | tz | teamM):
        n = set(G.neighbors(free))
        a = len(n & tx)
        b = len(n & ty)
        c = len(n & tz)

        tr = [a, b, c]
        if len(set(tr)) == 3:
         if tr.index(max(a, b, c)) == 0:
          teamX.add(free)
         elif tr.index(max(a, b, c)) == 1:
          teamY.add(free)
         elif tr.index(max(a, b, c)) == 2:
          teamZ.add(free)

       total = len(teamX) + len(teamY) + len(teamM) + len(teamZ)
       if total == prev:
        break
       else:
        prev = total

      zol[x] = len(teamX) - len(teamM)
      zol[y] = len(teamY) - len(teamM)
      zol[z] = len(teamZ) - len(teamM)

    cur = dict.fromkeys(G.es.indices, 0)

    for e in G.es:
      cur[e.index] = zol[e.source] + zol[e.target]

      for n in set(G.neighbors(e.source)) &  set(G.neighbors(e.target)):
        cur[e.index] += zol[n]
      
    a,b = zip(*Counter(cur).most_common())
    return a

M = 12
N = 4

for i in range(0, 1000):
 forbd = set()
 f = gen_sat(N, M, random_cnf(N))
 g, _ = sat_to_clique(f)
 G = ig.Graph.from_networkx(g)
 
 ite = 0
 while True:
  ite += 1
  d = diffactor(G)
  
  cut = None

  for e in d:
   des = G.vs[G.es[e].source]["_nx_name"][1]
   det = G.vs[G.es[e].target]["_nx_name"][1]
   if det not in forbd and des not in forbd:
    cut = frozenset(Counter([G.vs[G.es[e].source]["_nx_name"][0], G.vs[G.es[e].target]["_nx_name"][0]]).most_common())
    break
  
  todel = set()
  for e in G.es.indices:
    if cut == frozenset(Counter([G.vs[G.es[e].source]["_nx_name"][0], G.vs[G.es[e].target]["_nx_name"][0]]).most_common()):
      des = G.vs[G.es[e].source]["_nx_name"][1]
      det = G.vs[G.es[e].target]["_nx_name"][1]

      if det not in forbd and des not in forbd:
          forbd.add(des)
          forbd.add(det)
          todel.add(e)

  if len(todel) == 0:
    break

  G.delete_edges(todel)
 
 print(ite)
 if (G.clique_number() != M):
    print(G.ecount())
    print(G.vcount())
    print(G.degree())
    break
