import math
import statistics

def f_wrapper(G, result):
    def f(V, s, params=None):

        if type(s) == int:
            s = [list(G.vs.indices)[s]]
        else:
            s = list(itertools.chain(*(i if isinstance(i, list) else (i,) for i in s)))
            s = [list(G.vs.indices)[n] for n in s]

        s = tuple(sorted(s))

        if s in result:
            return result[s]
        
        H = G.copy()
        ids = set()
        for h in s:
          for e in H.neighbors(h):
            if e not in s:
              id = H.get_eid(e, h, error = False)
              if id != -1:
                ids.add(id)
                 
        H.delete_edges(ids)
        H.vs.select(_degree=0).delete()
        result[s] = (oni(H) * -1)
        return result[s]

    return f

def oni(G):
  res = list()
  for p,q in itertools.combinations(list(G.layout_fruchterman_reingold()), 2):
    res.append(math.dist(p, q))
  return statistics.stdev(res)

def solve(G):
    result = {}

    transition = []

    for v in G.vs:
        nxt = [0.0] * G.vcount()
        for n in v.neighbors():
            nxt[n.index] = 1.0
        transition.append(nxt)

    Q = np.array(transition)
    io = QUEYRANNE(Q, f_wrapper(G, result))
    return io

N = 4
M = 9

satis = True

for _ in range(0, 100):
 f = gen_sat(N, M, random_cnf(N)) if satis else gen_unsat(N, M)
 g, k = sat_to_clique(f)
 G = ig.Graph.from_networkx(g)
 tf, _ = zip(*k.values())
 wall = dict.fromkeys(tf, 0)
 m = solve(G)
 for a, b in reversed(m):
  for e in a:
    wall[G.vs[e]["_nx_name"][0]] += b
 
 a, b = zip(*Counter(wall).most_common())

 if (asol(f, asum = [a[-1]]) == []):
  print("Shit")
