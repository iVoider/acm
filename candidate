def diffactor(G):

    zol = {}

    for e in G.es:

      x = e.source
      y = e.target

      teamX = set(G.neighbors(x)) - set(G.neighbors(y))
      teamY = set(G.neighbors(y)) - set(G.neighbors(x))
      teamM = set(G.neighbors(x)) & set(G.neighbors(y))
      teamX.add(x)
      teamY.add(y)
      if x in teamY:
       teamY.remove(x)

      if y in teamX:
       teamX.remove(y)

      if y in teamM:
       teamM.remove(y)

      if x in teamM:
       teamM.remove(x)

      prev = len(teamX) + len(teamY) + len(teamM)
      total = prev

      while prev < G.vcount():
       tx = teamX.copy()
       ty = teamY.copy()
       for peace in teamM.copy():
        n = set(G.neighbors(peace))
        a = len(n & tx)
        b = len(n & ty)
        if  a > b:
          teamX.add(peace)
          teamM.remove(peace)
        elif a < b:
          teamY.add(peace)
          teamM.remove(peace)

       tx = teamX.copy()
       ty = teamY.copy()
       for free in set(G.vs.indices) - (tx | ty | teamM):
        n = set(G.neighbors(free))
        a = len(n & tx)
        b = len(n & ty)
        if a > b:
          teamX.add(free)
        elif a < b:
          teamY.add(free)

       total = len(teamX) + len(teamY) + len(teamM)
       if total == prev:
        break
       else:
        prev = total

      if total < G.vcount():
        for e in (set(G.vs.indices) - (teamX | teamY | teamM)):
          zol[G.vs[e]["_nx_name"]] = abs(len(teamX) - len(teamY))

    return sorted(zol.values())

def gen_hard_sat(N, M):
  f = gen_sat(N, M, random_cnf(N))
  g, _ = sat_to_clique(f)
  G = ig.Graph.from_networkx(g)
  H = None

  while True:

   net = dict.fromkeys(G.es.indices, 0)
   for c in G.largest_cliques():
    for x,y in itertools.combinations(c, 2):
      net[G.get_eid(x, y)] += 1
  
   G.delete_edges(min(net, key = net.get))

   if G.clique_number() < M:
    if len(H.largest_cliques()) == 1:
     for x,y in itertools.combinations(G.vs.indices, 2):
      if G.get_eid(x, y, error = False) == -1:
        G.add_edge(x, y)
        if G.clique_number() == M - 1:
           return H, G
        G.delete_edges(G.get_eid(x, y, error = False))
      return gen_hard_sat(N, M)
    else:
     return gen_hard_sat(N, M)
   else:
    H = G.copy()


N = 4
M = 13

for j in range(0, 10):
  #f = gen_sat(N, M, random_cnf(4))
  G, H = gen_hard_sat(N, M)
  print(diffactor(G))
  print(diffactor(H))
  print("------")
