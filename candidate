def f_wrapper(G, size, result):
    def f(V, s, params=None):

        if type(s) == int:
            s = [list(G.vs.indices)[s]]
        else:
            s = list(itertools.chain(*(i if isinstance(i, list) else (i,) for i in s)))
            s = [list(G.vs.indices)[n] for n in s]

        s = tuple(sorted(s))

        if s in result:
            return result[s]

        mapping = [0] * G.vcount()
        for e in s:
          mapping[e] = 1
        result[s] = leidenalg.find_partition(G,partition_type=leidenalg.ModularityVertexPartition, n_iterations=0, 
                                             initial_membership=mapping).modularity * (vars_bad(G, s) +  vars_bad(G, set(G.vs.indices) - set(s)))
        return result[s]

    return f


def solve(G, size):
    result = {}

    transition = []

    for v in G.vs:
        nxt = [0.0] * G.vcount()
        for n in v.neighbors():
            nxt[n.index] = 1.0
        transition.append(nxt)

    Q = np.array(transition)
    io = QUEYRANNE(Q, f_wrapper(G, size, result))
    return io
