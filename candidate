import math
import statistics

def f_wrapper(G, result):
    def f(V, s, params=None):

        if type(s) == int:
            s = [list(G.vs.indices)[s]]
        else:
            s = list(itertools.chain(*(i if isinstance(i, list) else (i,) for i in s)))
            s = [list(G.vs.indices)[n] for n in s]

        s = tuple(sorted(s))

        if s in result:
            return result[s]
        
        H = G.copy()
        ids = set()
        for h in s:
          for e in H.neighbors(h):
            if e not in s:
              id = H.get_eid(e, h, error = False)
              if id != -1:
                ids.add(id)
                 
        H.delete_edges(ids)
        H.vs.select(_degree=0).delete()
        result[s] = (oni(H) * -1)
        return result[s]

    return f

def oni(G):
  res = list()
  for p,q in itertools.combinations(list(G.layout_fruchterman_reingold()), 2):
    res.append(math.dist(p, q))
  return statistics.stdev(res)

def solve(G):
    result = {}

    transition = []

    for v in G.vs:
        nxt = [0.0] * G.vcount()
        for n in v.neighbors():
            nxt[n.index] = 1.0
        transition.append(nxt)

    Q = np.array(transition)
    io = QUEYRANNE(Q, f_wrapper(G, result))
    return io

N = 4
M = 9

satis = True

for _ in range(0, 100):
 f = gen_sat(N, M, random_cnf(N)) if satis else gen_unsat(N, M)
 g, k = sat_to_clique(f)
 G = ig.Graph.from_networkx(g)
 
 forbidden = set()

 while G.vcount() > 12:
   m = solve(G)
   to = None
   for e in reversed(m):
     if len(e[0]) == 1 and G.vs[e[0][0]]["_nx_name"][0] not in forbidden:
      to = G.vs[e[0][0]]["_nx_name"][0]
      forbidden.add(to * -1)
      break
 
   if to is None:
     break

   sub = set()
   for v in G.vs:
    if (v["_nx_name"][0] == to * -1):
     sub.add(v)
   
   prev = G.ecount()
   G.delete_vertices(sub)

   if G.ecount() == prev:
    break

 if G.clique_number() < 9:
   print(f)
 else:
   print(G.vcount())
